#!/usr/bin/env python

from __future__ import print_function

import sys, os
import time
import signal


wakeuptime = None
message = "Wake up!"


# Tkinter changed capitalization from Python 2 to Python 3.
# Python 2: import Tkinter as tkinter
# Python 3: import tkinter
# The error trying to import a nonexistent module also changed:
# Python2 raises ImportError, while Python3 raises ModuleNotFoundError
# which is a class of ImportError. Use ImportError because both
# Python versions understand it.
try:
    import tkinter
    # This may throw ImportError in Python 2 or ModuleNotFoundError in Py 3.
except ImportError:
    # In case it's Python 2, try importing it the Python 2 way:
    try:
        import Tkinter as tkinter
    except ImportError:
        print("Sorry, ImportError, eggtimer needs Tkinter")
        sys.exit(1)


# Callback for key events:
def keyEvent(event):
    # print(event.char, event.keysym, event.keycode)
    if event.char == 'q' or event.keysym == 'Return':
        sys.exit(0)


def Usage():
    print("Usage:", sys.argv[0], "minutes message")
    print("With no arguments, will show any eggtimers currently running")
    sys.exit(0)


def showAlert(message:str):
    # This is supposed to show a dialog, but tkMessageBox doesn't exist:
    # tkMessageBox.showwarning("hello", message)

    # Try to beep a bit, even though that doesn't work on some distros:
    print("")
    # print message

    root = tkinter.Tk()

    button = tkinter.Button(root, text=message,
                            bg="red", activebackground="red",
                            fg="white", activeforeground="white",
                            font=("Sans", 40, "bold"),
                            command=quit)

    # Make sure the window is at least as big as the screen:
    button.pack(ipadx=root.winfo_screenwidth()/2,
                ipady=root.winfo_screenheight()/2)

    # Apparently we can't bind key events to a button, only to the root:
    root.bind("<Key>", keyEvent)

    root.mainloop()


# main: read the runtime arguments.
if __name__ == '__main__':

    if len(sys.argv) == 1:
        # Find all running eggtimer processes and send them a SIGUSR1
        foundone = False
        slashproc = "/proc"
        for pid in os.listdir(slashproc):
            try:
                # Make sure the directory name is an integer PID
                pidint = int(pid)
                # Skip the PID of this process
                if pidint == os.getpid():
                    continue
                # Look for other eggtimer processes
                with open(os.path.join(slashproc, pid, "cmdline")) as fp:
                    cmdline = fp.read().split('\0')
                    if "python" not in cmdline[0]:
                        continue
                    if not (cmdline[1].endswith("eggtimer") or
                            cmdline[1].endswith("eggtimer.py")):
                        continue
                    foundone = True
                    os.kill(pidint, signal.SIGUSR1)
            except:
                pass

        if not foundone:
            Usage()

        sys.exit(0)

    try:
      sleeptime = float(sys.argv[1]) * 60
    except ValueError:
      Usage()

    if len(sys.argv) > 2:
      message = ' '.join(sys.argv[2:])

    print("Sleeping for", sleeptime, "seconds with message:", message)

    # Return control to the shell before sleeping:
    rc = os.fork()
    if rc:
        sys.exit(0)

    # Set up a signal handler so users can query for time left
    def signal_handler(signal, frame):
        timeleft = int(wakeuptime - time.time())
        print("In", timeleft, "seconds:", message, "(PID %d)" % os.getpid())

        time.sleep(timeleft)

        showAlert(message)

    # Trap SIGUSR1
    signal.signal(signal.SIGUSR1, signal_handler)

    wakeuptime = time.time() + sleeptime

    time.sleep(sleeptime)
    print("woke up")

    showAlert(message)
