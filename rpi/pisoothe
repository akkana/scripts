#!/usr/bin/env python

# pisooth: play soothing noise files (rain, water etc.) in a loop,
# while scanning for user input to control skipping to the next
# file, shutting down or other options.
#
# Copyright 2012 by Akkana Peck, http://shallowsky.com.
# Share and enjoy under the GPLv2 or (at your option) any later version.
#
# It's called pisoothe because it's intended as a script that will
# turn a Raspberry Pi into a sleep soother machine you can take with
# you on trips.
# To use this on as the sole program on a Raspberry Pi (q will shut down),
# add the following to the end of /etc/rc.local:
# 
# /path/to/pisoothe file1.wav file2.wav ...
# /sbin/poweroff
#
# Take input from a keyboard if there is one, or mouse if we're not in X,
# for volume, changing track, and shutdown.
# http://pythonhosted.org/evdev/

import sys, os
import subprocess
import time             # for sleep()
import termios, fcntl   # For non-blocking key reads
import alsaaudio
try:
    import evdev
    import select
    use_mouse = True
except:
    use_mouse = False

class SoundPlayer :
    """
       Asynchronously play sounds that don't overlap in time.
       Allow for querying whether a sound is still playing,
       or killing it to start a new sound.
    """

    PLAYER = "/usr/bin/aplay"

    def __init__(self, file_list, debug=False) :
        self.curpath = None
        self.current = None
        self.file_list = file_list
        self.samplenum = 0

        self.retcode = -1
        self.debug = debug

        self.vol_increment = 4

        try:
            self.mixer = alsaaudio.Mixer('Master', 0)
        except alsaaudio.ALSAAudioError:
            try:
                self.mixer = alsaaudio.Mixer('PCM', 0)
            except alsaaudio.ALSAAudioError:
                sys.stderr.write("No such mixer\n")
                self.mixer = None

    def __del__(self) :
        self.kill()

    def kill(self) :
        if self.current :
            if self.debug :
                print "Killing"
            self.current.kill()   # or try terminate()
        elif self.debug : print "Already dead, no need to kill"

    def skip_track(self, direction):
        print "Next sound"
        self.samplenum += direction
        if self.samplenum < 0:
            self.samplenum = len(self.file_list) - 1
        elif self.samplenum >= len(self.file_list):
            self.samplenum = 0
        self.play(True)

    def change_volume(self, direction):
        if not self.mixer:
            print "Can't change volume -- no mixer"
            return
        if direction == 0:
            return
        if self.debug:
            if direction > 0:
                print "Louder"
            else:
                print "Quieter"

        cur = self.mixer.getvolume()[0]
        cur += self.vol_increment * direction
        if cur > 100:
            cur = 100
        if cur < 0:
            cur = 0
        self.mixer.setvolume(cur, alsaaudio.MIXER_CHANNEL_ALL)
        if self.debug:
            print "Set volume to", cur

    def play(self, interrupt=False) :
        path = self.file_list[self.samplenum]
        if self.current :
            if self.current.poll() is None :
                # Current process hasn't finished yet. Is this the same sound?
                if path == self.curpath :
                    # A repeat of the currently playing sound.
                    # Don't play it more than once.
                    if self.debug :
                        print path, "is still playing. Not playing again"
                    return
                elif interrupt :
                    # Stop the currently playing process,
                    # so we can play a new one.
                    self.kill()
                    if self.debug :
                        print "Waiting for process to die:",
                    while self.current.poll() == None :
                        time.sleep(.2)
                        if self.debug :
                            print ".",
                    if self.debug :
                        print "Gone."
                else :
                    # Trying to play a different sound.
                    # Wait on the current sound then play the new one.
                    if self.debug :
                        print "Different sound; first waiting for", self.curpath
                    self.wait()
            self.current = None
            self.curpath = None

        if self.debug :
            print "Playing", path

        self.curpath = path
        self.current = subprocess.Popen([ SoundPlayer.PLAYER, '-q', path ] )

    def poll(self) :
        '''Returns None if currently playing, else last exit code.'''
        if not self.current :
            return self.retcode
        poll = self.current.poll()
        if poll != None :
            self.retcode = self.current.returncode
            self.current = None
            self.curpath = None
        return poll

    def is_done(self):
        '''Simpler version of retcode: returns True if the process is
           finished, False otherwise.
        '''
        if not self.current :
            return True
        return self.poll() != None

    def wait(self):
        if self.current and self.current.poll() is None:
            self.current.wait()

class KeyReader :
    '''
    Read keypresses one at a time, without waiting for a newline.
    Uses the technique from
    http://docs.python.org/2/faq/library.html#how-do-i-get-a-single-keypress-at-a-time
    '''
    def __init__(self, echo=False) :
        '''Put the terminal into cbreak and noecho mode.'''
        self.fd = sys.stdin.fileno()

        self.oldterm = termios.tcgetattr(self.fd)
        newattr = termios.tcgetattr(self.fd)
        newattr[3] = newattr[3] & ~termios.ICANON
        if not echo :
            newattr[3] = newattr[3] & ~termios.ECHO
        termios.tcsetattr(self.fd, termios.TCSANOW, newattr)

        self.oldflags = fcntl.fcntl(self.fd, fcntl.F_GETFL)
        fcntl.fcntl(self.fd, fcntl.F_SETFL, self.oldflags | os.O_NONBLOCK)

        # Sad hack: when the destructor __del__ is called,
        # the fcntl module may already be unloaded, so we can no longer
        # call fcntl.fcntl() to set the terminal back to normal.
        # So just in case, store a reference to the fcntl module,
        # and also to termios (though I haven't yet seen a case
        # where termios was gone -- for some reason it's just fnctl).
        # The idea of keeping references to the modules comes from
        # http://bugs.python.org/issue5099
        # though I don't know if it'll solve the problem completely.
        self.fcntl = fcntl
        self.termios = termios

    def __del__(self) :
        '''Reset the terminal before exiting the program.'''
        self.termios.tcsetattr(self.fd, self.termios.TCSAFLUSH, self.oldterm)
        self.fcntl.fcntl(self.fd, self.fcntl.F_SETFL, self.oldflags)

    def getch(self) :
        '''Read keyboard input, returning a string.
           Note that one key may result in a string of more than one character,
           e.g. arrow keys that send escape sequences.
           There may also be multiple keystrokes queued up since the last read.

           This function, sadly, cannot read special characters like VolumeUp.
           They don't show up in ordinary CLI reads -- you have to be in
           a window system like X to get those special keycodes.
        '''
        try:
            return sys.stdin.read()
        except IOError:
            return None

class MouseReader:
    def __init__(self):
        self.mousedevice = None
        devices = map(evdev.InputDevice, evdev.list_devices())
        for dev in devices:
            caps = dev.capabilities()
            keys = caps.keys()
            # 1L is "EV_KEY" events (mouse buttons);
            # 2L is 'EV_REL' for the wheel.
            if evdev.ecodes.EV_KEY in keys and evdev.ecodes.EV_REL in keys:
                if evdev.ecodes.BTN_LEFT in caps[evdev.ecodes.EV_KEY] and \
                        evdev.ecodes.BTN_RIGHT in caps[evdev.ecodes.EV_KEY] \
                        and evdev.ecodes.REL_WHEEL in caps[evdev.ecodes.EV_REL]:
                       # Quacks like a mouse. Use it.
                    self.mousedevice = dev
                    return

        if not mousedevice:
            print "Didn't see a mouse device"

    def pval(self, code, val):
        try:
            codes = evdev.ecodes.BTN[code]
            if type(codes) is list:
                print codes[0],
            else:
                print codes,
        except:
            try:
                print evdev.ecodes.REL[code],
            except:
                print "Unknown code", code

        if val == 1:
            if code == evdev.ecodes.REL_WHEEL:
                print "scroll up"
            else:
                print "press"
        elif val == 0:
            print "release"
        elif val == -1:
            print "scroll down"
        else:
            print "unknown value", val

    def read_mouse(self, timeout=None):
        '''Returns an evdev event.
           timeout is specified in floating-point seconds.
           timeout=None will block until there's something to read.
        '''
        r,w,x = select.select([self.mousedevice], [], [], timeout)
        if not r:
            return []
        events = []
        for event in self.mousedevice.read():
            # Only return codes for main three buttons plus wheel.
            if event.code in (evdev.ecodes.REL_WHEEL,
                              evdev.ecodes.BTN_LEFT,
                              evdev.ecodes.BTN_RIGHT,
                              evdev.ecodes.BTN_MIDDLE):
                events.append((event.code, event.value))
        return events

# main
# Pass sound files as arguments.
# pisoothe ambient_rain.wav caribbeanbeach_near.wav storm_water_2.wav
if __name__ == "__main__" :
    if len(sys.argv) < 1 :
        print "Usage: %s soundfile soundfile soundfile ..." % sys.argv[0]
        sys.exit(1)

    # Use input from a mouse if we're reading one:
    if use_mouse:
        try:
            mousereader = MouseReader()
            if not mousereader.mousedevice:
                mousereader = None
        except:
            mousereader = None
    else:
        mousereader = None

    try:
        readkey = KeyReader()
    except:
        readkey = None

    player = SoundPlayer(sys.argv[1:], debug=True)
    player.play()

    while True :
        time.sleep(1)

        if mousereader:
            events = mousereader.read_mouse(0)

            # First look for a left and right pressed at the same time.
            # That will be a signal to exit or maybe power down
            # the computer.
            if (evdev.ecodes.BTN_LEFT, 1) in events and \
                    (evdev.ecodes.BTN_RIGHT, 1) in events:
                print "Yowee! Right and left buttons pressed at once!"
                # On most systems. use sys.exit. On the RPi, shut down.
                if os.path.exists("/etc/rpi-issue"):
                    print "We're on a Raspberry Pi -- shutting down!"
                    os.system("/sbin/poweroff")
                    sys.exit(0)
                print "(not a Raspberry Pi)"
                sys.exit(0)

            for ev in events:
                if ev[0] == evdev.ecodes.BTN_RIGHT and ev[1] == 1:
                    player.skip_track(1)
                    continue
                   
                if ev[0] == evdev.ecodes.BTN_LEFT and ev[1] == 1:
                    player.skip_track(-1)
                    continue
                   
                if ev[0] == evdev.ecodes.REL_WHEEL:
                    player.change_volume(ev[1])

        if readkey:
            c = readkey.getch()
        else:
            c = None
        if not c :   # Didn't read anything. Is the current sound still playing?
            if player.is_done() :
                player.play()
            continue

        # Else we did read a character. Act on it:
        if c == 'q' :
            # print "Bye!"
            sys.exit(0)
        if c == 'n' :
            player.skip_track(1)
            continue
        if c == 'p' :
            player.skip_track(-1)
            continue
        if c == '\x1b[A' :   # Up arrow
            player.change_volume(1)
            continue
        if c == '\x1b[B' :   # Down arrow
            player.change_volume(-1)
            continue
        # If we get here, it was an unrecognized character.
        print "Don't know key",
        for cc in c :
            o = ord(cc)
            if o < 32 : cc = ' '    # Don't try to print nonprintables
            print '%c (%d)' % (cc, o),
        print
